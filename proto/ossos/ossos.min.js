class Vec3 extends Array{static UP=[0,1,0];static DOWN=[0,-1,0];static LEFT=[-1,0,0];static RIGHT=[1,0,0];static FORWARD=[0,0,1];static BACK=[0,0,-1];constructor(v,y,z){super(3),v instanceof Vec3||v instanceof Float32Array||v instanceof Array&&3==v.length?(this[0]=v[0],this[1]=v[1],this[2]=v[2]):"number"==typeof v&&"number"==typeof y&&"number"==typeof z?(this[0]=v,this[1]=y,this[2]=z):"number"==typeof v?(this[0]=v,this[1]=v,this[2]=v):(this[0]=0,this[1]=0,this[2]=0)}get len(){return Math.sqrt(this[0]**2+this[1]**2+this[2]**2)}get lenSqr(){return this[0]**2+this[1]**2+this[2]**2}get isZero(){return 0===this[0]&&0===this[1]&&0===this[2]}clone(){return new Vec3(this)}xyz(x,y,z){return this[0]=x,this[1]=y,this[2]=z,this}copy(a){return this[0]=a[0],this[1]=a[1],this[2]=a[2],this}copyTo(a){return a[0]=this[0],a[1]=this[1],a[2]=this[2],this}setInfinite(sign=1){return this[0]=1/0*sign,this[1]=1/0*sign,this[2]=1/0*sign,this}rnd(x0=0,x1=1,y0=0,y1=1,z0=0,z1=1){let t;return t=Math.random(),this[0]=x0*(1-t)+x1*t,t=Math.random(),this[1]=y0*(1-t)+y1*t,t=Math.random(),this[2]=z0*(1-t)+z1*t,this}fromAdd(a,b){return this[0]=a[0]+b[0],this[1]=a[1]+b[1],this[2]=a[2]+b[2],this}fromSub(a,b){return this[0]=a[0]-b[0],this[1]=a[1]-b[1],this[2]=a[2]-b[2],this}fromMul(a,b){return this[0]=a[0]*b[0],this[1]=a[1]*b[1],this[2]=a[2]*b[2],this}fromScale(a,s){return this[0]=a[0]*s,this[1]=a[1]*s,this[2]=a[2]*s,this}fromScaleThenAdd(scale,a,b){return this[0]=a[0]*scale+b[0],this[1]=a[1]*scale+b[1],this[2]=a[2]*scale+b[2],this}fromCross(a,b){const ax=a[0],ay=a[1],az=a[2],bx=b[0],by=b[1],bz=b[2];return this[0]=ay*bz-az*by,this[1]=az*bx-ax*bz,this[2]=ax*by-ay*bx,this}fromNorm(a){let mag=Math.sqrt(a[0]**2+a[1]**2+a[2]**2);return 0!=mag?(mag=1/mag,this[0]=a[0]*mag,this[1]=a[1]*mag,this[2]=a[2]*mag):(this[0]=0,this[1]=0,this[2]=0),this}fromNegate(a){return this[0]=-a[0],this[1]=-a[1],this[2]=-a[2],this}fromInvert(a){return this[0]=1/a[0],this[1]=1/a[1],this[2]=1/a[2],this}fromQuat(q,v=[0,0,1]){return this.copy(v).transformQuat(q)}fromLerp(a,b,t){const ti=1-t;return this[0]=a[0]*ti+b[0]*t,this[1]=a[1]*ti+b[1]*t,this[2]=a[2]*ti+b[2]*t,this}fromSlerp(a,b,t){const angle=Math.acos(Math.min(Math.max(Vec3.dot(a,b),-1),1)),sin=Math.sin(angle),ta=Math.sin((1-t)*angle)/sin,tb=Math.sin(t*angle)/sin;return this[0]=ta*a[0]+tb*b[0],this[1]=ta*a[1]+tb*b[1],this[2]=ta*a[2]+tb*b[2],this}fromArc(radius,u,v,rad,offset=[0,0,0]){const s=Math.sin(rad),c=Math.cos(rad);return this[0]=offset[0]+radius*(c*u[0]+s*v[0]),this[1]=offset[1]+radius*(c*u[1]+s*v[1]),this[2]=offset[2]+radius*(c*u[2]+s*v[2]),this}fromReflect(dir,norm=[0,1,0]){const factor=-2*Vec3.dot(norm,dir);return this[0]=factor*norm[0]+dir[0],this[1]=factor*norm[1]+dir[1],this[2]=factor*norm[2]+dir[2],this}fromBuf(ary,idx){return this[0]=ary[idx],this[1]=ary[idx+1],this[2]=ary[idx+2],this}toBuf(ary,idx){return ary[idx]=this[0],ary[idx+1]=this[1],ary[idx+2]=this[2],this}add(a){return this[0]+=a[0],this[1]+=a[1],this[2]+=a[2],this}sub(v){return this[0]-=v[0],this[1]-=v[1],this[2]-=v[2],this}mul(v){return this[0]*=v[0],this[1]*=v[1],this[2]*=v[2],this}scale(v){return this[0]*=v,this[1]*=v,this[2]*=v,this}divScale(v){return this[0]/=v,this[1]/=v,this[2]/=v,this}addScaled(a,s){return this[0]+=a[0]*s,this[1]+=a[1]*s,this[2]+=a[2]*s,this}invert(){return this[0]=1/this[0],this[1]=1/this[1],this[2]=1/this[2],this}norm(){let mag=Math.sqrt(this[0]**2+this[1]**2+this[2]**2);return 0!=mag&&(mag=1/mag,this[0]*=mag,this[1]*=mag,this[2]*=mag),this}cross(b){const ax=this[0],ay=this[1],az=this[2],bx=b[0],by=b[1],bz=b[2];return this[0]=ay*bz-az*by,this[1]=az*bx-ax*bz,this[2]=ax*by-ay*bx,this}abs(){return this[0]=Math.abs(this[0]),this[1]=Math.abs(this[1]),this[2]=Math.abs(this[2]),this}floor(){return this[0]=Math.floor(this[0]),this[1]=Math.floor(this[1]),this[2]=Math.floor(this[2]),this}ceil(){return this[0]=Math.ceil(this[0]),this[1]=Math.ceil(this[1]),this[2]=Math.ceil(this[2]),this}min(a){return this[0]=Math.min(this[0],a[0]),this[1]=Math.min(this[1],a[1]),this[2]=Math.min(this[2],a[2]),this}max(a){return this[0]=Math.max(this[0],a[0]),this[1]=Math.max(this[1],a[1]),this[2]=Math.max(this[2],a[2]),this}nearZero(){return Math.abs(this[0])<=1e-6&&(this[0]=0),Math.abs(this[1])<=1e-6&&(this[1]=0),Math.abs(this[2])<=1e-6&&(this[2]=0),this}negate(){return this[0]=-this[0],this[1]=-this[1],this[2]=-this[2],this}clamp(min,max){return this[0]=Math.min(Math.max(this[0],min[0]),max[0]),this[1]=Math.min(Math.max(this[1],min[1]),max[1]),this[2]=Math.min(Math.max(this[2],min[2]),max[2]),this}dot(b){return this[0]*b[0]+this[1]*b[1]+this[2]*b[2]}alignTwist(axis,dir){return this.fromCross(dir,axis).fromCross(axis,this),this}planeProj(planePos,planeNorm){const planeConst=-Vec3.dot(planePos,planeNorm),scl=-(Vec3.dot(planeNorm,this)+planeConst);return this[0]+=planeNorm[0]*scl,this[1]+=planeNorm[1]*scl,this[2]+=planeNorm[2]*scl,this}transformQuat(q){const qx=q[0],qy=q[1],qz=q[2],qw=q[3],vx=this[0],vy=this[1],vz=this[2],x1=qy*vz-qz*vy,y1=qz*vx-qx*vz,z1=qx*vy-qy*vx,x2=qw*x1+qy*z1-qz*y1,y2=qw*y1+qz*x1-qx*z1,z2=qw*z1+qx*y1-qy*x1;return this[0]=vx+2*x2,this[1]=vy+2*y2,this[2]=vz+2*z2,this}axisAngle(axis,rad){const cp=(new Vec3).fromCross(axis,this),dot=Vec3.dot(axis,this),s=Math.sin(rad),c=Math.cos(rad),ci=1-c;return this[0]=this[0]*c+cp[0]*s+axis[0]*dot*ci,this[1]=this[1]*c+cp[1]*s+axis[1]*dot*ci,this[2]=this[2]*c+cp[2]*s+axis[2]*dot*ci,this}rotate(rad,axis="x"){const sin=Math.sin(rad),cos=Math.cos(rad),x=this[0],y=this[1],z=this[2];switch(axis){case"y":this[0]=z*sin+x*cos,this[2]=z*cos-x*sin;break;case"x":this[1]=y*cos-z*sin,this[2]=y*sin+z*cos;break;case"z":this[0]=x*cos-y*sin,this[1]=x*sin+y*cos}return this}static len(a){return Math.sqrt(a[0]**2+a[1]**2+a[2]**2)}static lenSqr(a){return a[0]**2+a[1]**2+a[2]**2}static dist(a,b){return Math.sqrt((a[0]-b[0])**2+(a[1]-b[1])**2+(a[2]-b[2])**2)}static distSqr(a,b){return(a[0]-b[0])**2+(a[1]-b[1])**2+(a[2]-b[2])**2}static norm(v,out=new Vec3){let mag=Math.sqrt(v[0]**2+v[1]**2+v[2]**2);return 0==mag||(mag=1/mag,out[0]=v[0]*mag,out[1]=v[1]*mag,out[2]=v[2]*mag),out}static dot(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]}static cross(a,b,out=new Vec3){const ax=a[0],ay=a[1],az=a[2],bx=b[0],by=b[1],bz=b[2];return out[0]=ay*bz-az*by,out[1]=az*bx-ax*bz,out[2]=ax*by-ay*bx,out}static orthogonal(fwd,up=[0,1,0]){const zAxis=new Vec3(fwd),xAxis=(new Vec3).fromCross(up,zAxis).norm();0===Vec3.lenSqr(xAxis)&&(1===Math.abs(up[2])?zAxis[0]+=1e-4:zAxis[2]+=1e-4,zAxis.norm(),xAxis.fromCross(up,zAxis).norm());return[xAxis,(new Vec3).fromCross(zAxis,xAxis).norm(),zAxis]}static scaleThenAdd(scale,a,b,out=new Vec3){return out[0]=a[0]*scale+b[0],out[1]=a[1]*scale+b[1],out[2]=a[2]*scale+b[2],out}static fromQuat(q,v=[0,0,1]){return new Vec3(v).transformQuat(q)}static angle(a,b){const d=this.dot(a,b),c=(new Vec3).fromCross(a,b);return Math.atan2(Vec3.len(c),d)}}class Quat extends Array{static LOOKXP=[0,-.7071067811865475,0,.7071067811865475];static LOOKXN=[0,.7071067811865475,0,.7071067811865475];static LOOKYP=[.7071067811865475,0,0,.7071067811865475];static LOOKYN=[-.7071067811865475,0,0,.7071067811865475];static LOOKZP=[0,-1,0,0];static LOOKZN=[0,0,0,1];constructor(v){super(4),v instanceof Quat||v instanceof Float32Array||v instanceof Array&&4==v.length?(this[0]=v[0],this[1]=v[1],this[2]=v[2],this[3]=v[3]):(this[0]=0,this[1]=0,this[2]=0,this[3]=1)}identity(){return this[0]=0,this[1]=0,this[2]=0,this[3]=1,this}copy(a){return this[0]=a[0],this[1]=a[1],this[2]=a[2],this[3]=a[3],this}copyTo(a){return a[0]=this[0],a[1]=this[1],a[2]=this[2],a[3]=this[3],this}clone(){return new Quat(this)}fromMul(a,b){const ax=a[0],ay=a[1],az=a[2],aw=a[3],bx=b[0],by=b[1],bz=b[2],bw=b[3];return this[0]=ax*bw+aw*bx+ay*bz-az*by,this[1]=ay*bw+aw*by+az*bx-ax*bz,this[2]=az*bw+aw*bz+ax*by-ay*bx,this[3]=aw*bw-ax*bx-ay*by-az*bz,this}fromNorm(a){let len=a[0]**2+a[1]**2+a[2]**2+a[3]**2;return len>0&&(len=1/Math.sqrt(len),this[0]=a[0]*len,this[1]=a[1]*len,this[2]=a[2]*len,this[3]=a[3]*len),this}fromAxisAngle(axis,rad){const half=.5*rad,s=Math.sin(half);return this[0]=axis[0]*s,this[1]=axis[1]*s,this[2]=axis[2]*s,this[3]=Math.cos(half),this}fromSwing(a,b){const dot=Vec3.dot(a,b);if(dot<-.999999){const tmp=(new Vec3).fromCross(Vec3.LEFT,a);tmp.len<1e-6&&tmp.fromCross(Vec3.UP,a),this.fromAxisAngle(tmp.norm(),Math.PI)}else if(dot>.999999)this[0]=0,this[1]=0,this[2]=0,this[3]=1;else{const v=Vec3.cross(a,b,[0,0,0]);this[0]=v[0],this[1]=v[1],this[2]=v[2],this[3]=1+dot,this.norm()}return this}fromInvert(q){const a0=q[0],a1=q[1],a2=q[2],a3=q[3],dot=a0*a0+a1*a1+a2*a2+a3*a3;if(0==dot)return this[0]=this[1]=this[2]=this[3]=0,this;const invDot=1/dot;return this[0]=-a0*invDot,this[1]=-a1*invDot,this[2]=-a2*invDot,this[3]=a3*invDot,this}fromNegate(q){return this[0]=-q[0],this[1]=-q[1],this[2]=-q[2],this[3]=-q[3],this}fromLookDir(dir,up=[0,1,0]){const zAxis=new Vec3(dir).norm(),xAxis=(new Vec3).fromCross(up,zAxis).norm(),yAxis=(new Vec3).fromCross(zAxis,xAxis).norm(),m00=xAxis[0],m01=xAxis[1],m02=xAxis[2],m10=yAxis[0],m11=yAxis[1],m12=yAxis[2],m20=zAxis[0],m21=zAxis[1],m22=zAxis[2],t=m00+m11+m22;let x,y,z,w,s;return t>0?(s=Math.sqrt(t+1),w=.5*s,s=.5/s,x=(m12-m21)*s,y=(m20-m02)*s,z=(m01-m10)*s):m00>=m11&&m00>=m22?(s=Math.sqrt(1+m00-m11-m22),x=.5*s,s=.5/s,y=(m01+m10)*s,z=(m02+m20)*s,w=(m12-m21)*s):m11>m22?(s=Math.sqrt(1+m11-m00-m22),y=.5*s,s=.5/s,x=(m10+m01)*s,z=(m21+m12)*s,w=(m20-m02)*s):(s=Math.sqrt(1+m22-m00-m11),z=.5*s,s=.5/s,x=(m20+m02)*s,y=(m21+m12)*s,w=(m01-m10)*s),this[0]=x,this[1]=y,this[2]=z,this[3]=w,this}fromNBlend(a,b,t){const a_x=a[0],a_y=a[1],a_z=a[2],a_w=a[3],b_x=b[0],b_y=b[1],b_z=b[2],b_w=b[3],ti=1-t,s=a_x*b_x+a_y*b_y+a_z*b_z+a_w*b_w<0?-1:1;return this[0]=ti*a_x+t*b_x*s,this[1]=ti*a_y+t*b_y*s,this[2]=ti*a_z+t*b_z*s,this[3]=ti*a_w+t*b_w*s,this.norm()}fromBuf(ary,idx){return this[0]=ary[idx],this[1]=ary[idx+1],this[2]=ary[idx+2],this[3]=ary[idx+3],this}toBuf(ary,idx){return ary[idx]=this[0],ary[idx+1]=this[1],ary[idx+2]=this[2],ary[idx+3]=this[3],this}fromEuler(x,y,z){let xx=0,yy=0,zz=0;x instanceof Vec3||x instanceof Float32Array||x instanceof Array&&3==x.length?(xx=.01745329251*x[0]*.5,yy=.01745329251*x[1]*.5,zz=.01745329251*x[2]*.5):"number"==typeof x&&"number"==typeof y&&"number"==typeof z&&(xx=.01745329251*x*.5,yy=.01745329251*y*.5,zz=.01745329251*z*.5);const c1=Math.cos(xx),c2=Math.cos(yy),c3=Math.cos(zz),s1=Math.sin(xx),s2=Math.sin(yy),s3=Math.sin(zz);return this[0]=s1*c2*c3+c1*s2*s3,this[1]=c1*s2*c3-s1*c2*s3,this[2]=c1*c2*s3-s1*s2*c3,this[3]=c1*c2*c3+s1*s2*s3,this.norm()}mul(q){const ax=this[0],ay=this[1],az=this[2],aw=this[3],bx=q[0],by=q[1],bz=q[2],bw=q[3];return this[0]=ax*bw+aw*bx+ay*bz-az*by,this[1]=ay*bw+aw*by+az*bx-ax*bz,this[2]=az*bw+aw*bz+ax*by-ay*bx,this[3]=aw*bw-ax*bx-ay*by-az*bz,this}pmul(q){const ax=q[0],ay=q[1],az=q[2],aw=q[3],bx=this[0],by=this[1],bz=this[2],bw=this[3];return this[0]=ax*bw+aw*bx+ay*bz-az*by,this[1]=ay*bw+aw*by+az*bx-ax*bz,this[2]=az*bw+aw*bz+ax*by-ay*bx,this[3]=aw*bw-ax*bx-ay*by-az*bz,this}norm(){let len=this[0]**2+this[1]**2+this[2]**2+this[3]**2;return len>0&&(len=1/Math.sqrt(len),this[0]*=len,this[1]*=len,this[2]*=len,this[3]*=len),this}invert(){const a0=this[0],a1=this[1],a2=this[2],a3=this[3],dot=a0*a0+a1*a1+a2*a2+a3*a3;if(0==dot)return this[0]=this[1]=this[2]=this[3]=0,this;const invDot=1/dot;return this[0]=-a0*invDot,this[1]=-a1*invDot,this[2]=-a2*invDot,this[3]=a3*invDot,this}negate(){return this[0]=-this[0],this[1]=-this[1],this[2]=-this[2],this[3]=-this[3],this}rotX(rad){rad*=.5;const ax=this[0],ay=this[1],az=this[2],aw=this[3],bx=Math.sin(rad),bw=Math.cos(rad);return this[0]=ax*bw+aw*bx,this[1]=ay*bw+az*bx,this[2]=az*bw-ay*bx,this[3]=aw*bw-ax*bx,this}rotY(rad){rad*=.5;const ax=this[0],ay=this[1],az=this[2],aw=this[3],by=Math.sin(rad),bw=Math.cos(rad);return this[0]=ax*bw-az*by,this[1]=ay*bw+aw*by,this[2]=az*bw+ax*by,this[3]=aw*bw-ay*by,this}rotZ(rad){rad*=.5;const ax=this[0],ay=this[1],az=this[2],aw=this[3],bz=Math.sin(rad),bw=Math.cos(rad);return this[0]=ax*bw+ay*bz,this[1]=ay*bw-ax*bz,this[2]=az*bw+aw*bz,this[3]=aw*bw-az*bz,this}rotDeg(deg,axis=0){const rad=deg*Math.PI/180;switch(axis){case 0:this.rotX(rad);break;case 1:this.rotY(rad);break;case 2:this.rotZ(rad)}return this}pmulInvert(q){let ax=q[0],ay=q[1],az=q[2],aw=q[3];const dot=ax*ax+ay*ay+az*az+aw*aw;if(0===dot)ax=ay=az=aw=0;else{const dot_inv=1/dot;ax=-ax*dot_inv,ay=-ay*dot_inv,az=-az*dot_inv,aw*=dot_inv}const bx=this[0],by=this[1],bz=this[2],bw=this[3];return this[0]=ax*bw+aw*bx+ay*bz-az*by,this[1]=ay*bw+aw*by+az*bx-ax*bz,this[2]=az*bw+aw*bz+ax*by-ay*bx,this[3]=aw*bw-ax*bx-ay*by-az*bz,this}pmulAxisAngle(axis,rad){const half=.5*rad,s=Math.sin(half),ax=axis[0]*s,ay=axis[1]*s,az=axis[2]*s,aw=Math.cos(half),bx=this[0],by=this[1],bz=this[2],bw=this[3];return this[0]=ax*bw+aw*bx+ay*bz-az*by,this[1]=ay*bw+aw*by+az*bx-ax*bz,this[2]=az*bw+aw*bz+ax*by-ay*bx,this[3]=aw*bw-ax*bx-ay*by-az*bz,this}dotNegate(q,chk){return Quat.dot(q,chk)<0?this.fromNegate(q):this.copy(q),this}static dot(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]+a[3]*b[3]}static lenSqr(a,b){return(a[0]-b[0])**2+(a[1]-b[1])**2+(a[2]-b[2])**2+(a[3]-b[3])**2}static nblend(a,b,t,out){const a_x=a[0],a_y=a[1],a_z=a[2],a_w=a[3],b_x=b[0],b_y=b[1],b_z=b[2],b_w=b[3],ti=1-t,s=a_x*b_x+a_y*b_y+a_z*b_z+a_w*b_w<0?-1:1;return out[0]=ti*a_x+t*b_x*s,out[1]=ti*a_y+t*b_y*s,out[2]=ti*a_z+t*b_z*s,out[3]=ti*a_w+t*b_w*s,out.norm()}static slerp(a,b,t,out){const ax=a[0],ay=a[1],az=a[2],aw=a[3];let omega,cosom,sinom,scale0,scale1,bx=b[0],by=b[1],bz=b[2],bw=b[3];return cosom=ax*bx+ay*by+az*bz+aw*bw,cosom<0&&(cosom=-cosom,bx=-bx,by=-by,bz=-bz,bw=-bw),1-cosom>1e-6?(omega=Math.acos(cosom),sinom=Math.sin(omega),scale0=Math.sin((1-t)*omega)/sinom,scale1=Math.sin(t*omega)/sinom):(scale0=1-t,scale1=t),out[0]=scale0*ax+scale1*bx,out[1]=scale0*ay+scale1*by,out[2]=scale0*az+scale1*bz,out[3]=scale0*aw+scale1*bw,out}static shortest(from,to,out){const ax=from[0],ay=from[1],az=from[2],aw=from[3];let bx=to[0],by=to[1],bz=to[2],bw=to[3];ax*bx+ay*by+az*bz+aw*bw<0&&(bx=-bx,by=-by,bz=-bz,bw=-bw);const d=bx*bx+by*by+bz*bz+bw*bw;if(0===d)bx=0,by=0,bz=0,bw=0;else{const di=1/d;bx=-bx*di,by=-by*di,bz=-bz*di,bw*=di}return out[0]=ax*bw+aw*bx+ay*bz-az*by,out[1]=ay*bw+aw*by+az*bx-ax*bz,out[2]=az*bw+aw*bz+ax*by-ay*bx,out[3]=aw*bw-ax*bx-ay*by-az*bz,out}static swing(a,b){return(new Quat).fromSwing(a,b)}static axisAngle(axis,rad){return(new Quat).fromAxisAngle(axis,rad)}}class Transform{rot=new Quat;pos=new Vec3(0);scl=new Vec3(1);constructor(rot,pos,scl){rot instanceof Transform?this.copy(rot):rot&&pos&&scl&&this.set(rot,pos,scl)}reset(){return this.rot.identity(),this.pos.xyz(0,0,0),this.scl.xyz(1,1,1),this}copy(t){return this.rot.copy(t.rot),this.pos.copy(t.pos),this.scl.copy(t.scl),this}set(r,p,s){return r&&this.rot.copy(r),p&&this.pos.copy(p),s&&this.scl.copy(s),this}clone(){return new Transform(this)}mul(cr,cp,cs){return cr instanceof Transform&&(cp=cr.pos,cs=cr.scl,cr=cr.rot),cr&&cp&&(this.pos.add((new Vec3).fromMul(this.scl,cp).transformQuat(this.rot)),cs&&this.scl.mul(cs),this.rot.mul(cr)),this}pmul(pr,pp,ps){return pr instanceof Transform&&(pp=pr.pos,ps=pr.scl,pr=pr.rot),pr&&pp&&ps?(this.pos.mul(ps).transformQuat(pr).add(pp),ps&&this.scl.mul(ps),this.rot.pmul(pr),this):this}addPos(cp,ignoreScl=!1){return ignoreScl?this.pos.add((new Vec3).fromQuat(this.rot,cp)):this.pos.add((new Vec3).fromMul(cp,this.scl).transformQuat(this.rot)),this}fromMul(tp,tc){const v=(new Vec3).fromMul(tp.scl,tc.pos).transformQuat(tp.rot);return this.pos.fromAdd(tp.pos,v),this.scl.fromMul(tp.scl,tc.scl),this.rot.fromMul(tp.rot,tc.rot),this}fromInvert(t){return this.rot.fromInvert(t.rot),this.scl.fromInvert(t.scl),this.pos.fromNegate(t.pos).mul(this.scl).transformQuat(this.rot),this}transformVec3(v,out){return(out||v).fromMul(v,this.scl).transformQuat(this.rot).add(this.pos)}}class Bone{index=-1;pindex=-1;name="";len=0;local=new Transform;world=new Transform;children=[];constraint=null;constructor(props){this.name=props?.name?props.name:"bone"+Math.random(),"number"==typeof props?.parent&&(this.pindex=props.parent),props?.parent instanceof Bone&&(this.pindex=props.parent.index),props?.rot&&this.local.rot.copy(props.rot),props?.pos&&this.local.pos.copy(props.pos),props?.scl&&this.local.scl.copy(props.scl),props?.len&&(this.len=props.len)}clone(){const b=new Bone;return b.name=this.name,b.index=this.index,b.pindex=this.pindex,b.len=this.len,b.constraint=this.constraint,b.children=this.children.slice(),b.local.copy(this.local),b.world.copy(this.world),b}}class Pose{arm;offset=new Transform;linkedBone=void 0;bones=new Array;srcPose=void 0;constructor(arm){if(arm&&(this.arm=arm),arm?.poses?.bind){this.srcPose=arm.poses.bind;for(let i=0;i<arm.poses.bind.bones.length;i++)this.bones.push(arm.poses.bind.bones[i].clone());this.offset.copy(arm.poses.bind.offset)}}getBone(o){switch(typeof o){case"string":{const idx=this.arm.names.get(o);return void 0!==idx?this.bones[idx]:null}case"number":return this.bones[o]}return null}getBones(ary){const rtn=[];let b;for(const i of ary)(b=this.getBone(i))&&rtn.push(b);return rtn}clone(){const p=new Pose;p.arm=this.arm,p.offset.copy(this.offset);for(const b of this.bones)p.bones.push(b.clone());return p}getWorldTailPos(o,out=new Vec3){const b=this.getBone(o);return b&&b.world.transformVec3(out.xyz(0,b.len,0)),out}setLocalPos(boneId,v){const bone=this.getBone(boneId);return bone&&bone.local.pos.copy(v),this}setLocalRot(boneId,v){const bone=this.getBone(boneId);return bone&&bone.local.rot.copy(v),this}copy(pose){const bLen=this.bones.length;this.srcPose=pose;for(let i=0;i<bLen;i++)this.bones[i].local.copy(pose.bones[i].local),this.bones[i].world.copy(pose.bones[i].world);return this}reset(){if(this.srcPose){const bLen=this.bones.length,p=this.srcPose;for(let i=0;i<bLen;i++)this.bones[i].local.copy(p.bones[i].local),this.bones[i].world.copy(p.bones[i].world)}return this}updateWorld(){for(const b of this.bones)-1!==b.pindex?b.world.fromMul(this.bones[b.pindex].world,b.local):(b.world.fromMul(this.offset,b.local),this.linkedBone&&b.world.pmul(this.linkedBone.world));return this}updateWorldChildren(pIdx,incParent=!1){const parents=[pIdx];let b;incParent&&(b=this.bones[pIdx],b.world.fromMul(-1!==b.pindex?this.bones[b.pindex].world:this.offset,b.local));for(let i=pIdx+1;i<this.bones.length;i++)b=this.bones[i],-1!==parents.indexOf(b.pindex)&&(b.world.fromMul(this.bones[b.pindex].world,b.local),parents.push(b.index));return this}getWorldRotation(boneId,out=new Quat){let bone=this.getBone(boneId);if(!bone)return-1===boneId?out.copy(this.offset.rot):console.error("Pose.getWorldRotation - bone not found",boneId),out;for(out.copy(bone.local.rot);-1!==bone.pindex;)bone=this.bones[bone.pindex],out.pmul(bone.local.rot);return out.pmul(this.offset.rot),this.linkedBone&&out.pmul(this.linkedBone.world.rot),out}getWorldTransform(boneId,out=new Transform){let bone=this.getBone(boneId);if(!bone)return-1===boneId?out.copy(this.offset):console.error("Pose.getWorldTransform - bone not found",boneId),out;for(out.copy(bone.local);-1!==bone.pindex;)bone=this.bones[bone.pindex],out.pmul(bone.local);return out.pmul(this.offset),this.linkedBone&&out.pmul(this.linkedBone.world),out}getWorldPosition(boneId,out=new Vec3){return out.copy(this.getWorldTransform(boneId).pos)}rotLocal(boneId,deg,axis=0){const bone=this.getBone(boneId);if(bone)switch(axis){case 1:bone.local.rot.rotY(deg*Math.PI/180);break;case 2:bone.local.rot.rotZ(deg*Math.PI/180);break;default:bone.local.rot.rotX(deg*Math.PI/180)}else console.warn("Bone not found, ",boneId);return this}rotWorld(boneId,deg,axis="x"){const bone=this.getBone(boneId);if(bone){const pWRot=this.getWorldRotation(bone.pindex),ax="y"==axis?[0,1,0]:"z"==axis?[0,0,1]:[1,0,0];new Quat(pWRot).mul(bone.local.rot).pmulAxisAngle(ax,deg*Math.PI/180).pmulInvert(pWRot).copyTo(bone.local.rot)}else console.error("Pose.rotWorld - bone not found",boneId);return this}moveLocal(boneId,offset){const bone=this.getBone(boneId);return bone?bone.local.pos.add(offset):console.warn("Pose.moveLocal - bone not found, ",boneId),this}posLocal(boneId,pos){const bone=this.getBone(boneId);return bone?bone.local.pos.copy(pos):console.warn("Pose.posLocal - bone not found, ",boneId),this}sclLocal(boneId,v){const bone=this.getBone(boneId);return bone?v instanceof Array||v instanceof Float32Array?bone.local.scl.copy(v):"number"==typeof v&&bone.local.scl.xyz(v,v,v):console.warn("Pose.sclLocal - bone not found, ",boneId),this}}class Armature{skin;names=new Map;poses={bind:new Pose(this)};get bindPose(){return this.poses.bind}get boneCount(){return this.poses.bind.bones.length}newPose(saveAs){const p=this.poses.bind.clone();return saveAs&&(this.poses[saveAs]=p),p}addBone(obj){const bones=this.poses.bind.bones,idx=bones.length;if(obj instanceof Bone)return obj.index=idx,bones.push(obj),this.names.set(obj.name,idx),obj;{const bone=new Bone(obj);if(bone.index=idx,bones.push(bone),this.names.set(bone.name,idx),null!=obj?.parent){let pIdx=-1;switch(obj.parent.constructor.name){case"Number":pIdx=obj.parent;break;case"String":pIdx=this.names.get(obj.parent);break;case"Bone":pIdx=obj.parent.index;break;default:console.log("Unknown parent type",obj.parent)}-1!==pIdx&&null!=pIdx?(bone.pindex=pIdx,bones[pIdx].children.push(bone.index)):console.error("Parent bone not found",obj.name)}return bone}}getBone(o){switch(typeof o){case"string":{const idx=this.names.get(o);return void 0!==idx?this.poses.bind.bones[idx]:null}case"number":return this.poses.bind.bones[o]}return null}getBones(ary){const rtn=[];let b;for(const i of ary)(b=this.getBone(i))&&rtn.push(b);return rtn}bind(boneLen=.2){return this.poses.bind.updateWorld(),this.updateBoneLengths(this.poses.bind,boneLen),this}useSkin(skin){switch(typeof skin){case"object":this.skin=skin;break;case"function":this.skin=new skin(this.poses.bind);break;default:console.error("Armature.useSkin, unknown typeof of skin ref",skin)}return this.skin}updateBoneLengths(_pose,boneLen=.1){const pose=_pose||this.poses.bind;let b,p;for(let i=pose.bones.length-1;i>=0;i--)b=pose.bones[i],-1!==b.pindex&&(p=pose.bones[b.pindex],p.len=Vec3.dist(p.world.pos,b.world.pos),p.len<1e-4&&(p.len=0));if(0!=boneLen)for(b of pose.bones)0==b.len&&(b.len=boneLen);return this}}class BoneBindings{onUpdate;items=new Map;constructor(fn){this.onUpdate=fn}bind(bone,obj){return this.items.set(window.crypto.randomUUID(),{bone:new WeakRef(bone),obj:new WeakRef(obj)}),this}removeBone(bone){const trash=[];let b,k,v;for([k,v]of this.items)b=v.bone.deref(),b&&b!==bone||trash.push(k);if(trash.length>0)for(k of trash)this.items.delete(k);return this}updateAll(){const trash=[];let b,o,k,v;for([k,v]of this.items)b=v.bone.deref(),o=v.obj.deref(),b&&o?this.onUpdate(b,o):trash.push(k);if(trash.length>0)for(k of trash)this.items.delete(k);return this}}class SocketItem{local=new Transform;obj;constructor(obj,pos,rot,scl){this.obj=obj,pos&&this.local.pos.copy(pos),rot&&this.local.rot.copy(rot),scl&&this.local.scl.copy(scl)}}class Socket{boneIndex=-1;local=new Transform;items=[];constructor(bi,pos,rot){this.boneIndex=bi,pos&&this.local.pos.copy(pos),rot&&this.local.rot.copy(rot)}}class BoneSockets{sockets=new Map;transformHandler;constructor(tHandler){tHandler&&(this.transformHandler=tHandler)}add(name,bone,pos,rot){return this.sockets.set(name,new Socket(bone.index,pos,rot)),this}attach(socketName,obj,pos,rot,scl){const s=this.sockets.get(socketName);return s?s.items.push(new SocketItem(obj,pos,rot,scl)):console.error("Socket.attach: Socket name not found:",socketName),this}updateFromPose(pose){if(!this.transformHandler)return;const st=new Transform,t=new Transform;let b;for(const s of this.sockets.values()){b=pose.bones[s.boneIndex],st.fromMul(b.world,s.local);for(const i of s.items){t.fromMul(st,i.local);try{this.transformHandler(t,i.obj)}catch(err){const msg=err instanceof Error?err.message:String(err);console.error("Error updating bone socket item: ",msg)}}}}debugAll(pose,debug){const t=new Transform;let b;for(const s of this.sockets.values())b=pose.bones[s.boneIndex],t.fromMul(b.world,s.local),debug.pnt.add(t.pos,16777215,4,2)}}class BoneMap{bones=new Map;obj;constructor(obj){obj&&this.from(obj)}from(obj){this.obj=obj;const bAry=obj instanceof Armature?obj.bindPose.bones:obj.bones;let bp,bi,key;for(const b of bAry)for(bp of Parsers)if(key=bp.test(b.name)){bi=this.bones.get(key),bi?bi&&bp.isChain&&bi.push(b):this.bones.set(key,new BoneInfo(b));break}}getBoneMap(name){return this.bones.get(name)}getBoneIndex(name){const bi=this.bones.get(name);return bi?bi.items[0].index:-1}getBones(aryNames){const bAry=this.obj instanceof Armature?this.obj.bindPose.bones:this.obj.bones,rtn=[];let bi,i;for(const name of aryNames)if(bi=this.bones.get(name),bi)for(i of bi.items)rtn.push(bAry[i.index]);else console.warn("Bonemap.getBones - Bone not found",name);return rtn.length>=aryNames.length?rtn:null}getBoneNames(ary){const rtn=[];let bi,i;for(const name of ary){if(!(bi=this.bones.get(name)))return console.warn("Bonemap.getBoneNames - Bone not found",name),null;for(i of bi.items)rtn.push(i.name)}return rtn}getChestBone(){const bAry=this.obj instanceof Armature?this.obj.bindPose.bones:this.obj.bones,rtn=[],bi=this.bones.get("spine");return bi&&rtn.push(bAry[bi.lastIndex]),rtn.length>0?rtn:null}getBoneSet(n){const bs=BONE_SETS[n],ary=[];let bi;for(let i of bs){if(bi=this.bones.get(i),!bi)return console.log("Missing bone: ",i,"for set",n),null;for(const bii of bi.items)ary.push(this.obj.bones[bii.index])}return ary}}class BoneInfo{items=[];constructor(b){b&&this.push(b)}push(bone){return this.items.push({index:bone.index,name:bone.name}),this}get isChain(){return this.items.length>1}get count(){return this.items.length}get index(){return this.items[0].index}get lastIndex(){return this.items[this.items.length-1].index}}const BONE_SETS={leftArm:["upperarm_l","forearm_l","hand_l"],rightArm:["upperarm_r","forearm_r","hand_r"],leftLeg:["thigh_l","shin_l","ankle_l"],rightLeg:["thigh_r","shin_r","ankle_r"],hip:["hip"],spine:["spine"],head:["head"]};class BoneParse{name;isLR;isChain;reFind;reExclude;constructor(name,isLR,reFind,reExclude,isChain=!1){this.name=name,this.isLR=isLR,this.isChain=isChain,this.reFind=new RegExp(reFind,"i"),reExclude&&(this.reExclude=new RegExp(reExclude,"i"))}test(bname){return this.reFind.test(bname)?this.reExclude&&this.reExclude.test(bname)?null:this.isLR&&reLeft.test(bname)?this.name+"_l":this.isLR&&reRight.test(bname)?this.name+"_r":this.name:null}}const reLeft=new RegExp("\\.l|left|_l","i"),reRight=new RegExp("\\.r|right|_r","i"),Parsers=[new BoneParse("thigh",!0,"thigh|up.*leg|hip(?!s)","twist"),new BoneParse("shin",!0,"shin|leg|calf|knee","up|twist"),new BoneParse("ankle",!0,"ankle"),new BoneParse("foot",!0,"foot"),new BoneParse("toe",!0,"toe"),new BoneParse("shoulder",!0,"clavicle|shoulder|collar","shoulder_BIND"),new BoneParse("upperarm",!0,"(upper.*arm|arm)|shoulder_BIND","fore|twist|lower"),new BoneParse("forearm",!0,"forearm|arm|elbow","up|twist"),new BoneParse("hand",!0,"hand|wrist","thumb|index|middle|ring|pinky"),new BoneParse("head",!1,"head"),new BoneParse("neck",!1,"neck"),new BoneParse("hip",!1,"hips*|pelvis"),new BoneParse("root",!1,"root"),new BoneParse("spine",!1,"spine.*d*|chest",void 0,!0)];class BoneAxes{static UFR=0;static RBD=1;static LBU=2;static DFR=3;static FUR=4;swing=new Vec3(Vec3.UP);twist=new Vec3(Vec3.FORWARD);ortho=new Vec3(Vec3.RIGHT);constructor(axes){axes&&this.copy(axes)}getFromQuat(q,rtn=new BoneAxes){return rtn.copy(this).applyQuat(q)}copy(axes){return this.swing.copy(axes.swing),this.twist.copy(axes.twist),this.ortho.copy(axes.ortho),this}applyQuat(q){return this.swing.fromQuat(q,this.swing).norm(),this.twist.fromQuat(q,this.twist).norm(),this.ortho.fromQuat(q,this.ortho).norm(),this}applyInvertQuat(q){const qi=(new Quat).fromInvert(q);return this.swing.fromQuat(qi,this.swing).norm(),this.twist.fromQuat(qi,this.twist).norm(),this.ortho.fromQuat(qi,this.ortho).norm(),this}setOrthogonal(swing,twist=[0,0,1]){return this.swing.copy(swing),this.ortho.fromCross(twist,this.swing).norm(),0===Vec3.lenSqr(this.ortho)&&(1===Math.abs(twist[2])?this.swing[0]+=1e-4:this.swing[2]+=1e-4,this.swing.norm(),this.ortho.fromCross(twist,this.swing).norm()),this.twist.fromCross(this.swing,this.ortho).norm(),this}setQuatDirections(q,ba=BoneAxes.UFR){switch(ba){case BoneAxes.UFR:this.swing.fromQuat(q,Vec3.UP),this.twist.fromQuat(q,Vec3.FORWARD),this.ortho.fromQuat(q,Vec3.RIGHT);break;case BoneAxes.RBD:this.swing.fromQuat(q,Vec3.RIGHT),this.twist.fromQuat(q,Vec3.BACK),this.ortho.fromQuat(q,Vec3.DOWN);break;case BoneAxes.LBU:this.swing.fromQuat(q,Vec3.LEFT),this.twist.fromQuat(q,Vec3.BACK),this.ortho.fromQuat(q,Vec3.UP);break;case BoneAxes.DFR:this.swing.fromQuat(q,Vec3.DOWN),this.twist.fromQuat(q,Vec3.FORWARD),this.ortho.fromQuat(q,Vec3.RIGHT);break;case BoneAxes.FUR:this.swing.fromQuat(q,Vec3.FORWARD),this.twist.fromQuat(q,Vec3.UP),this.ortho.fromQuat(q,Vec3.RIGHT)}return this.swing.norm(),this.twist.norm(),this.ortho.norm(),this}}class IKTarget{hasChanged=!1;tMode=0;pMode=0;deltaMove=new Vec3;endPos=new Vec3;startPos=new Vec3;polePos=new Vec3;dist=0;swing=new Vec3;twist=new Vec3;ortho=new Vec3;lenScale=-1;altSwing;altTwist;pworld=new Transform;rworld=new Transform;setPositions(t,p){return this.hasChanged=!0,this.tMode=0,this.pMode=0,this.endPos.copy(t),p&&this.polePos.copy(p),this}setPolePos(p){return this.hasChanged=!0,this.pMode=0,this.polePos.copy(p),this}setDirections(s,t,scl){return this.hasChanged=!0,this.swing.copy(s),this.tMode=1,t?(this.twist.copy(t),this.pMode=1):this.pMode=0,scl&&(this.lenScale=scl),this}setAltDirections(s,t){return this.hasChanged=!0,this.altSwing||(this.altSwing=new Vec3,this.altTwist=new Vec3),this.altSwing.copy(s),this.altTwist.copy(t),this}setPoleDir(p){return this.hasChanged=!0,this.pMode=1,this.twist.copy(p),this}setDeltaMove(p,scl=1){return this.deltaMove.copy(p).scale(scl),this.hasChanged=!0,this}resolveTarget(chain,pose){switch(pose.getWorldTransform(chain.links[0].pindex,this.pworld),this.rworld.fromMul(this.pworld,chain.links[0].bind),this.tMode){case 0:this.startPos.copy(this.rworld.pos),this.swing.fromSub(this.endPos,this.startPos),this.dist=this.swing.len,this.swing.norm();break;case 1:this.dist=this.lenScale>=0?this.lenScale*chain.len:chain.len,this.startPos.copy(this.rworld.pos),this.endPos.copy(this.swing).scale(this.dist).add(this.rworld.pos)}if(0===this.pMode)this.twist.fromSub(this.polePos,this.startPos),this.ortho.fromCross(this.twist,this.swing).norm(),this.twist.fromCross(this.swing,this.ortho).norm();return this.hasChanged=!1,this}debug(d){d.pnt.add(this.startPos,16777215,3,0),d.pnt.add(this.endPos,16777215,3,1),d.ln.add(this.startPos,this.endPos,16777215);const p=this.twist.clone().scale(.5).add(this.startPos);return d.ln.add(this.startPos,p,16777215),d.pnt.add(p,16777215,3,6),this}}class IKLink{index=-1;pindex=-1;len=0;axes=new BoneAxes;bind=new Transform;constructor(bone,swingTwist=-1){this.index=bone.index,this.pindex=bone.pindex,this.bind.copy(bone.local),-1!==swingTwist&&this.axes.setQuatDirections((new Quat).fromInvert(bone.world.rot),swingTwist)}}class IKChain{links=[];len=0;constructor(bones,swingTwist=-1){bones&&this.setBones(bones,swingTwist)}get lastLink(){return this.links[this.links.length-1]}get firstLink(){return this.links[0]}setBones(bones,swingTwist=-1){this.links.length=0,this.len=0;for(const b of bones)this.links.push(new IKLink(b,swingTwist));const li=bones.length-1;for(let i=1;i<=li;i++)this.links[i-1].len=Vec3.dist(bones[i].world.pos,bones[i-1].world.pos),this.len+=this.links[i-1].len;return this.links[li].len=bones[li].len,this}resetPoseLocal(pose,startIdx=0,endIdx=-1){let lnk;endIdx<0&&(endIdx=this.links.length-1);for(let i=startIdx;i<=endIdx;i++)lnk=this.links[i],pose.bones[lnk.index].local.rot.copy(lnk.bind.rot);return this}usePlacementForSwing(pose,twistDir=[0,1,1]){const swing=new Vec3;let a,b;for(let i=1;i<this.links.length;i++)a=this.links[i],b=this.links[i-1],swing.fromSub(pose.bones[a.index].world.pos,pose.bones[b.index].world.pos).norm(),b.axes.setOrthogonal(swing,twistDir).applyInvertQuat(pose.bones[b.index].world.rot);return b=this.links.at(-1),b.axes.setOrthogonal(swing,twistDir).applyInvertQuat(pose.bones[b.index].world.rot),this}debug(debug,pose){const t=new Transform,a=new BoneAxes,v=new Vec3;for(const l of this.links)pose.getWorldTransform(l.index,t),l.axes.getFromQuat(t.rot,a),debug.pnt.add(t.pos,16777215,1,0),debug.ln.add(t.pos,v.fromScaleThenAdd(.1,a.swing,t.pos),16777215),debug.ln.add(t.pos,v.fromScaleThenAdd(.1,a.twist,t.pos),16711935),debug.ln.add(t.pos,v.fromScaleThenAdd(.1,a.ortho,t.pos),7368816)}}function lookSolver(tar,chain,pose,Debug){const lnk=chain.links[0],tDir=new Vec3;tDir.fromQuat(tar.rworld.rot,lnk.axes.swing);const rot=(new Quat).fromSwing(tDir,tar.swing).mul(tar.rworld.rot);if(tDir.fromQuat(rot,lnk.axes.twist),Vec3.dot(tar.twist,tDir)<.999999){const twistReset=(new Quat).fromSwing(tDir,tar.twist);Quat.dot(twistReset,rot)<0&&twistReset.negate(),rot.pmul(twistReset)}rot.pmulInvert(tar.pworld.rot),pose.setLocalRot(lnk.index,rot),Debug&&(Debug.ln.add(tar.startPos,(new Vec3).fromAdd(tDir,tar.startPos),65280),Debug.ln.add(tar.startPos,(new Vec3).fromAdd(tar.twist,tar.startPos),16777215),Debug.ln.add(tar.startPos,tar.endPos,16777215))}function deltaMoveSolver(tar,chain,pose){const pTran=new Transform,cTran=new Transform,ptInv=new Transform,lnk=chain.firstLink;pose.getWorldTransform(lnk.pindex,pTran),cTran.fromMul(pTran,lnk.bind),ptInv.fromInvert(pTran),cTran.pos.add(tar.deltaMove),ptInv.transformVec3(cTran.pos),pose.setLocalPos(lnk.index,cTran.pos)}function rootCompose(target,chain,pose){target.resolveTarget(chain,pose),lookSolver(target,chain,pose),deltaMoveSolver(target,chain,pose)}function lookCompose(target,chain,pose){target.resolveTarget(chain,pose),lookSolver(target,chain,pose)}function lawcos_sss$1(aLen,bLen,cLen){const v=(aLen**2+bLen**2-cLen**2)/(2*aLen*bLen);return Math.acos(Math.min(1,Math.max(-1,v)))}function twoBoneSolver(tar,chain,pose,debug){const lnk0=chain.links[0],lnk1=chain.links[1],root=pose.getBone(lnk0.index),rot=(new Quat).fromMul(tar.pworld.rot,root.local.rot),bendAxis=Vec3.fromQuat(rot,lnk0.axes.ortho);let rad=lawcos_sss$1(lnk0.len,tar.dist,lnk1.len);rot.pmulAxisAngle(bendAxis,-rad).pmulInvert(tar.pworld.rot),pose.setLocalRot(lnk0.index,rot);const pRot=pose.getWorldRotation(lnk1.pindex);rad=Math.PI-lawcos_sss$1(lnk0.len,lnk1.len,tar.dist),rot.fromMul(pRot,lnk1.bind.rot).pmulAxisAngle(bendAxis,rad).pmulInvert(pRot),pose.setLocalRot(lnk1.index,rot)}function limbCompose(target,chain,pose,debug){target.resolveTarget(chain,pose),lookSolver(target,chain,pose),target.dist>=chain.len?chain.resetPoseLocal(pose,1):twoBoneSolver(target,chain,pose)}function trapezoidSolver(tar,chain,pose,debug){console.log("trapezoid"),debug.ln.add(tar.startPos,tar.endPos,65280),debug.pnt.add(tar.startPos,65280,6),debug.pnt.add(tar.endPos,65280,6);const ptran=new Transform,ctran=new Transform;let lnk;const axis=(new Vec3).fromCross(tar.twist,tar.swing).norm(),rot=new Quat,lft_len=chain.links[0].len,top_len=chain.links[1].len,rit_len=chain.links[2].len,bot_len=tar.dist;let ang;console.log("LENGTHS",lft_len,top_len,rit_len,bot_len),ang=function(){const equations=[{coefficient:1,constant:360},{coefficient:1,constant:180},{coefficient:1,constant:180},{coefficient:1,constant:0}],angles=[];for(let i=0;i<4;i++){const equation=equations[i],coefficient=equation.coefficient,constant=equation.constant;angles.push((constant-coefficient*angles[i-1])/coefficient)}return angles}(),ang=function(left,top,right,bottom){function angleFromSides(x,y,z){return Math.acos((x*x+z*z-y*y)/(2*x*z))}return[angleFromSides(left,bottom,Math.sqrt(left*left+bottom*bottom)),angleFromSides(top,left,Math.sqrt(top*top+left*left)),angleFromSides(right,top,Math.sqrt(right*right+top*top)),angleFromSides(bottom,right,Math.sqrt(bottom*bottom+right*right))]}(lft_len,top_len,rit_len,bot_len),ang=function(left,top,right,bottom){function angleBetweenSides(a,b,c){return Math.acos((a*a+c*c-b*b)/(2*a*c))}const diagonal1=Math.sqrt(left*left+(top-bottom)*(top-bottom)),diagonal2=Math.sqrt(right*right+(top-bottom)*(top-bottom));return[angleBetweenSides(left,bottom,diagonal1),angleBetweenSides(top,left,diagonal1),angleBetweenSides(right,top,diagonal2),angleBetweenSides(bottom,right,diagonal2)]}(rit_len,bot_len,lft_len,top_len),console.log(ang,ang.map(x=>180*x/Math.PI),[83,130,76]),lnk=chain.links[0],pose.getWorldTransform(lnk.pindex,ptran),ctran.fromMul(ptran,pose.getBone(lnk.index)?.local??lnk.bind),rot.fromAxisAngle(axis,-ang[2]).mul(ctran.rot).pmulInvert(ptran.rot),pose.setLocalRot(lnk.index,rot),lnk=chain.links[1],pose.getWorldTransform(lnk.pindex,ptran),ctran.fromMul(ptran,lnk.bind),rot.fromAxisAngle(axis,Math.PI-ang[1]).mul(ctran.rot).pmulInvert(ptran.rot),pose.setLocalRot(lnk.index,rot),lnk=chain.links[2],pose.getWorldTransform(lnk.pindex,ptran),ctran.fromMul(ptran,lnk.bind),rot.fromAxisAngle(axis,Math.PI-ang[3]).mul(ctran.rot).pmulInvert(ptran.rot),pose.setLocalRot(lnk.index,rot)}function trapezoidCompose(target,chain,pose,debug){target.resolveTarget(chain,pose),lookSolver(target,chain,pose),target.dist>=chain.len?chain.resetPoseLocal(pose,1):trapezoidSolver(target,chain,pose,debug)}function lawcos_sss(aLen,bLen,cLen){const v=(aLen**2+bLen**2-cLen**2)/(2*aLen*bLen);return Math.acos(Math.min(1,Math.max(-1,v)))}function ZSolver(tar,chain,pose,debug){const l0=chain.links[0],l1=chain.links[1],l2=chain.links[2],aLen=l0.len,bLen=l1.len,cLen=l2.len,bhLen=.5*bLen,ratio=(aLen+bhLen)/(aLen+bLen+cLen),taLen=tar.dist*ratio,tbLen=tar.dist-taLen,ptran=new Transform,ctran=new Transform,axis=(new Vec3).fromCross(tar.twist,tar.swing),rot=new Quat;let rad;const root=pose.getBone(l0.index)?.local??l0.bind;pose.getWorldTransform(l0.pindex,ptran),ctran.fromMul(ptran,root),rad=lawcos_sss(aLen,taLen,bhLen),rot.copy(ctran.rot).pmulAxisAngle(axis,-rad).pmulInvert(ptran.rot),pose.setLocalRot(l0.index,rot),pose.getWorldTransform(l1.pindex,ptran),ctran.fromMul(ptran,l1.bind),rad=Math.PI-lawcos_sss(aLen,bhLen,taLen),rot.copy(ctran.rot).pmulAxisAngle(axis,rad).pmulInvert(ptran.rot),pose.setLocalRot(l1.index,rot),pose.getWorldTransform(l2.pindex,ptran),ctran.fromMul(ptran,l2.bind),rad=Math.PI-lawcos_sss(cLen,bhLen,tbLen),rot.copy(ctran.rot).pmulAxisAngle(axis,-rad).pmulInvert(ptran.rot),pose.setLocalRot(l2.index,rot)}function zCompose(target,chain,pose,debug){target.resolveTarget(chain,pose),lookSolver(target,chain,pose),target.dist>=chain.len?chain.resetPoseLocal(pose,1):ZSolver(target,chain,pose)}function swingTwistChainSolver(tar,chain,pose,Debug){const cMax=chain.links.length-1,ptran=new Transform,ctran=new Transform,tDir=new Vec3,dir=new Vec3,sRot=new Quat,tRot=new Quat;let t,lnk;for(let i=0;i<=cMax;i++)lnk=chain.links[i],t=i/cMax,pose.getWorldTransform(lnk.pindex,ptran),ctran.fromMul(ptran,lnk.bind),tDir.fromLerp(tar.swing,tar.altSwing,t).norm(),dir.fromQuat(ctran.rot,lnk.axes.swing),sRot.fromSwing(dir,tDir).mul(ctran.rot),tDir.fromLerp(tar.twist,tar.altTwist,t).norm(),dir.fromQuat(sRot,lnk.axes.twist),tRot.fromSwing(dir,tDir).mul(sRot).pmulInvert(ptran.rot),pose.setLocalRot(lnk.index,tRot)}function calcAsincArc(tar,chain){const chordLen=tar.dist,arcLen=chain.len,arcAngle=2*function(x0){let x=6*(1-x0);const x1=x;let a=x;return x*=x1,a+=x/20,x*=x1,a+=2*x/525,x*=x1,a+=13*x/37800,x*=x1,a+=4957*x/14553e4,x*=x1,a+=58007*x/162162e5,x*=x1,a+=1748431*x/4469590125e3,x*=x1,a+=4058681*x/92100645e6,x*=x1,a+=5313239803*x/104624165646e7,x*=x1,a+=2601229460539*x/4365681093774e9,Math.sqrt(a)}(chordLen/arcLen);if(arcLen<=chordLen||isNaN(arcAngle)||arcAngle<=0||arcAngle>2*Math.PI)return null;const radius=arcLen/arcAngle,centerOffset=Math.sqrt(radius**2-(chordLen/2)**2),mid=(new Vec3).fromLerp(tar.startPos,tar.endPos,.5),up=tar.twist.clone();arcAngle<=Math.PI&&up.negate();return{radius:radius,arcAngle:arcAngle,centerOffset:centerOffset,chordLen:chordLen,centerPos:(new Vec3).fromScaleThenAdd(centerOffset,up,mid),midPos:mid,orthoAxis:tar.ortho}}function asincArcCompose(target,chain,pose,opts){target.resolveTarget(chain,pose),lookSolver(target,chain,pose);const o=calcAsincArc(target,chain);if(target.dist>=chain.len)chain.resetPoseLocal(pose,1);else if(o){const points=function(tar,chain,o,useChord=!0,opts){const points=Array.from({length:chain.links.length},()=>new Vec3);points[0].copy(tar.startPos);const u=new Vec3(tar.startPos).sub(o.centerPos).norm(),v=new Vec3(tar.endPos).sub(o.centerPos),p=(new Vec3).fromCross(u,v);v.fromCross(p,u).norm(),o.arcAngle>Math.PI&&v.negate(),opts?.revPole&&v.negate();let rad=0;if(useChord){const clamp=v2=>Math.min(1,Math.max(-1,v2));for(let i=0;i<chain.links.length-1;i++)rad+=2*Math.asin(clamp(chain.links[i].len/(2*o.radius))),points[i+1].fromArc(o.radius,u,v,rad,o.centerPos)}else{let len=0;for(let i=0;i<chain.links.length-1;i++)len+=chain.links[i].len,rad=len/chain.len*o.arcAngle,points[i+1].fromArc(o.radius,u,v,rad,o.centerPos)}u.fromSub(points.at(-1),tar.startPos).norm();const q=(new Quat).fromSwing(u,tar.swing);for(let p2 of points)p2.sub(tar.startPos).transformQuat(q).add(tar.startPos);return points}(target,chain,o,o.arcAngle<Math.PI,opts);!function(tar,chain,pnts){const v=new Vec3;pnts.at(-1)?.copy(tar.endPos);for(let i=chain.links.length-1;i>1;i--)v.fromSub(pnts[i-1],pnts[i]).norm().scale(chain.links[i-1].len).add(pnts[i]).copyTo(pnts[i-1])}(target,chain,points),function(chain,pnts){const v=new Vec3;for(let i=0;i<chain.links.length-1;i++)v.fromSub(pnts[i+1],pnts[i]).norm().scale(chain.links[i].len).add(pnts[i]).copyTo(pnts[i+1])}(chain,points),function(chain,pose,pnts){const fromDir=new Vec3,toDir=new Vec3,parent=new Transform;let lnk,bone;for(let i=0;i<chain.links.length-1;i++)lnk=chain.links[i],bone=pose.getBone(lnk.index),pose.getWorldTransform(bone.pindex,parent),bone.world.fromMul(parent,bone.local),fromDir.fromQuat(bone.world.rot,lnk.axes.swing).norm(),toDir.fromSub(pnts[i+1],bone.world.pos).norm(),bone.local.rot.fromSwing(fromDir,toDir).mul(bone.world.rot).pmulInvert(parent.rot).norm()}(chain,pose,points)}else console.log("AsincArcData is null")}const IK_SOLVERS={root:rootCompose,look:lookCompose,limb:limbCompose,z:zCompose,trapezoid:trapezoidCompose,swingchain:swingTwistChainSolver,asincarc:asincArcCompose};class IKSet{name="";order=0;target=new IKTarget;solver;chain;solverOptions={};constructor(name,order=0){this.name=name,this.order=order}setBones(bones,tPose,axes=BoneAxes.UFR){return this.chain=new IKChain(tPose.getBones(bones),axes),this}setSolver(s,o){return this.solver="string"==typeof s?IK_SOLVERS[s]:s,o&&(this.solverOptions=o),this}updatePose(pose){this.solver(this.target,this.chain,pose,this.solverOptions)}}class IKRig{sets=[];names={};pose;constructor(tpose){this.pose=tpose.clone()}addSet(opt){if(0===(opt=Object.assign({order:0,name:"",bones:[],axes:BoneAxes.UFR,solver:"look",solverOptions:void 0},opt)).bones.length)return this;opt.name||(opt.name="set"+this.sets.length);const s=new IKSet(opt.name,opt.order).setBones(opt.bones,this.pose,opt.axes).setSolver(opt.solver,opt.solverOptions);return this.sets.push(s),this.#reorder(),this}#reorder(){this.sets.sort((a,b)=>a.order===b.order?0:a.order<b.order?-1:1);for(let i=0;i<this.sets.length;i++)this.names[this.sets[i].name]=i}getSet(name){return this.sets[this.names[name]]}getEndPosition(name){const s=this.sets[this.names[name]];return this.pose.getWorldPosition(s.chain.lastLink.index)}setTargetPositions(name,tarPos,polPos){const s=this.sets[this.names[name]];return s?s.target.setPositions(tarPos,polPos):console.log("Setting target name not found",name),this}runSolvers(){return this.executor(this),this}executor=_rig=>{for(const s of this.sets)s.updatePose(this.pose);this.pose.updateWorld()}}class Maths{static TAU=6.283185307179586;static PI_H=1.5707963267948966;static TAU_INV=.15915494309189535;static PI_Q=.7853981633974483;static PI_Q3=2.356194490192345;static PI_270=Math.PI+1.5707963267948966;static DEG2RAD=.01745329251;static RAD2DEG=57.2957795131;static EPSILON=1e-6;static PHI=1.618033988749895;static clamp(v,min,max){return Math.max(min,Math.min(max,v))}static clampGrad(v){return Math.max(-1,Math.min(1,v))}static saturate(v){return Math.max(0,Math.min(1,v))}static fract(f){return f-Math.floor(f)}static nearZero(v){return Math.abs(v)<=Maths.EPSILON?0:v}static dotToDeg(dot){return Math.acos(Maths.clampGrad(dot))*Maths.RAD2DEG}static remap(x,xMin,xMax,zMin,zMax){return(x-xMin)/(xMax-xMin)*(zMax-zMin)+zMin}static snap(x,step){return Math.floor(x/step)*step}static norm(min,max,v){return(v-min)/(max-min)}static mod(a,b){const v=a%b;return v<0?b+v:v}static lerp(a,b,t){return a*(1-t)+b*t}static eerp(a,b,t){return a*(b/a)**t}static roundStep(value,step){return Math.round(value/step)*step}static smoothDamp(cur,tar,vel,dt,smoothTime=1e-4,maxSpeed=1/0){const omega=2/(smoothTime=Math.max(1e-4,smoothTime)),x=omega*dt,exp=1/(1+x+.48*x*x+.235*x*x*x);let change=cur-tar;const maxChange=maxSpeed*smoothTime;change=Math.min(maxChange,Math.max(change,-maxChange));const temp=(vel+omega*change)*dt;vel=(vel-omega*temp)*exp;let val=cur-change+(change+temp)*exp;return tar-cur>0&&val>tar&&(val=tar,vel=0),[val,vel]}}class Mat4 extends Array{static BYTESIZE=64;constructor(v){super(16),v?this.copy(v):(this[0]=1,this[1]=0,this[2]=0,this[3]=0,this[4]=0,this[5]=1,this[6]=0,this[7]=0,this[8]=0,this[9]=0,this[10]=1,this[11]=0,this[12]=0,this[13]=0,this[14]=0,this[15]=1)}identity(){return this[0]=1,this[1]=0,this[2]=0,this[3]=0,this[4]=0,this[5]=1,this[6]=0,this[7]=0,this[8]=0,this[9]=0,this[10]=1,this[11]=0,this[12]=0,this[13]=0,this[14]=0,this[15]=1,this}clearTranslation(){return this[12]=this[13]=this[14]=0,this[15]=1,this}copy(mat,offset=0){let i;for(i=0;i<16;i++)this[i]=mat[offset+i];return this}copyTo(out){let i;for(i=0;i<16;i++)out[i]=this[i];return this}determinant(){const a00=this[0],a01=this[1],a02=this[2],a03=this[3],a10=this[4],a11=this[5],a12=this[6],a13=this[7],a20=this[8],a21=this[9],a22=this[10],a23=this[11],a30=this[12],a31=this[13],a32=this[14],b0=a00*a11-a01*a10,b1=a00*a12-a02*a10,b2=a01*a12-a02*a11,b3=a20*a31-a21*a30,b4=a20*a32-a22*a30,b5=a21*a32-a22*a31;return a13*(a00*b5-a01*b4+a02*b3)-a03*(a10*b5-a11*b4+a12*b3)+this[15]*(a20*b2-a21*b1+a22*b0)-a23*(a30*b2-a31*b1+a32*b0)}frob(){return Math.hypot(this[0],this[1],this[2],this[3],this[4],this[5],this[6],this[7],this[8],this[9],this[10],this[11],this[12],this[13],this[14],this[15])}getTranslation(out){return(out=out||[0,0,0])[0]=this[12],out[1]=this[13],out[2]=this[14],out}getScale(out){const m11=this[0],m12=this[1],m13=this[2],m21=this[4],m22=this[5],m23=this[6],m31=this[8],m32=this[9],m33=this[10];return(out=out||[0,0,0])[0]=Math.sqrt(m11*m11+m12*m12+m13*m13),out[1]=Math.sqrt(m21*m21+m22*m22+m23*m23),out[2]=Math.sqrt(m31*m31+m32*m32+m33*m33),out}getRotation(out){const trace=this[0]+this[5]+this[10];let S=0;return out=out||[0,0,0,1],trace>0?(S=2*Math.sqrt(trace+1),out[3]=.25*S,out[0]=(this[6]-this[9])/S,out[1]=(this[8]-this[2])/S,out[2]=(this[1]-this[4])/S):this[0]>this[5]&&this[0]>this[10]?(S=2*Math.sqrt(1+this[0]-this[5]-this[10]),out[3]=(this[6]-this[9])/S,out[0]=.25*S,out[1]=(this[1]+this[4])/S,out[2]=(this[8]+this[2])/S):this[5]>this[10]?(S=2*Math.sqrt(1+this[5]-this[0]-this[10]),out[3]=(this[8]-this[2])/S,out[0]=(this[1]+this[4])/S,out[1]=.25*S,out[2]=(this[6]+this[9])/S):(S=2*Math.sqrt(1+this[10]-this[0]-this[5]),out[3]=(this[1]-this[4])/S,out[0]=(this[8]+this[2])/S,out[1]=(this[6]+this[9])/S,out[2]=.25*S),out}fromPerspective(fovy,aspect,near,far){const f=1/Math.tan(.5*fovy),nf=1/(near-far);return this[0]=f/aspect,this[1]=0,this[2]=0,this[3]=0,this[4]=0,this[5]=f,this[6]=0,this[7]=0,this[8]=0,this[9]=0,this[10]=(far+near)*nf,this[11]=-1,this[12]=0,this[13]=0,this[14]=2*far*near*nf,this[15]=0,this}fromOrtho(left,right,bottom,top,near,far){const lr=1/(left-right),bt=1/(bottom-top),nf=1/(near-far);return this[0]=-2*lr,this[1]=0,this[2]=0,this[3]=0,this[4]=0,this[5]=-2*bt,this[6]=0,this[7]=0,this[8]=0,this[9]=0,this[10]=2*nf,this[11]=0,this[12]=(left+right)*lr,this[13]=(top+bottom)*bt,this[14]=(far+near)*nf,this[15]=1,this}fromMul(a,b){const a00=a[0],a01=a[1],a02=a[2],a03=a[3],a10=a[4],a11=a[5],a12=a[6],a13=a[7],a20=a[8],a21=a[9],a22=a[10],a23=a[11],a30=a[12],a31=a[13],a32=a[14],a33=a[15];let b0=b[0],b1=b[1],b2=b[2],b3=b[3];return this[0]=b0*a00+b1*a10+b2*a20+b3*a30,this[1]=b0*a01+b1*a11+b2*a21+b3*a31,this[2]=b0*a02+b1*a12+b2*a22+b3*a32,this[3]=b0*a03+b1*a13+b2*a23+b3*a33,b0=b[4],b1=b[5],b2=b[6],b3=b[7],this[4]=b0*a00+b1*a10+b2*a20+b3*a30,this[5]=b0*a01+b1*a11+b2*a21+b3*a31,this[6]=b0*a02+b1*a12+b2*a22+b3*a32,this[7]=b0*a03+b1*a13+b2*a23+b3*a33,b0=b[8],b1=b[9],b2=b[10],b3=b[11],this[8]=b0*a00+b1*a10+b2*a20+b3*a30,this[9]=b0*a01+b1*a11+b2*a21+b3*a31,this[10]=b0*a02+b1*a12+b2*a22+b3*a32,this[11]=b0*a03+b1*a13+b2*a23+b3*a33,b0=b[12],b1=b[13],b2=b[14],b3=b[15],this[12]=b0*a00+b1*a10+b2*a20+b3*a30,this[13]=b0*a01+b1*a11+b2*a21+b3*a31,this[14]=b0*a02+b1*a12+b2*a22+b3*a32,this[15]=b0*a03+b1*a13+b2*a23+b3*a33,this}fromInvert(mat){const a00=mat[0],a01=mat[1],a02=mat[2],a03=mat[3],a10=mat[4],a11=mat[5],a12=mat[6],a13=mat[7],a20=mat[8],a21=mat[9],a22=mat[10],a23=mat[11],a30=mat[12],a31=mat[13],a32=mat[14],a33=mat[15],b00=a00*a11-a01*a10,b01=a00*a12-a02*a10,b02=a00*a13-a03*a10,b03=a01*a12-a02*a11,b04=a01*a13-a03*a11,b05=a02*a13-a03*a12,b06=a20*a31-a21*a30,b07=a20*a32-a22*a30,b08=a20*a33-a23*a30,b09=a21*a32-a22*a31,b10=a21*a33-a23*a31,b11=a22*a33-a23*a32;let det=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;return det?(det=1/det,this[0]=(a11*b11-a12*b10+a13*b09)*det,this[1]=(a02*b10-a01*b11-a03*b09)*det,this[2]=(a31*b05-a32*b04+a33*b03)*det,this[3]=(a22*b04-a21*b05-a23*b03)*det,this[4]=(a12*b08-a10*b11-a13*b07)*det,this[5]=(a00*b11-a02*b08+a03*b07)*det,this[6]=(a32*b02-a30*b05-a33*b01)*det,this[7]=(a20*b05-a22*b02+a23*b01)*det,this[8]=(a10*b10-a11*b08+a13*b06)*det,this[9]=(a01*b08-a00*b10-a03*b06)*det,this[10]=(a30*b04-a31*b02+a33*b00)*det,this[11]=(a21*b02-a20*b04-a23*b00)*det,this[12]=(a11*b07-a10*b09-a12*b06)*det,this[13]=(a00*b09-a01*b07+a02*b06)*det,this[14]=(a31*b01-a30*b03-a32*b00)*det,this[15]=(a20*b03-a21*b01+a22*b00)*det,this):this}fromAdjugate(a){const a00=a[0],a01=a[1],a02=a[2],a03=a[3],a10=a[4],a11=a[5],a12=a[6],a13=a[7],a20=a[8],a21=a[9],a22=a[10],a23=a[11],a30=a[12],a31=a[13],a32=a[14],a33=a[15],b00=a00*a11-a01*a10,b01=a00*a12-a02*a10,b02=a00*a13-a03*a10,b03=a01*a12-a02*a11,b04=a01*a13-a03*a11,b05=a02*a13-a03*a12,b06=a20*a31-a21*a30,b07=a20*a32-a22*a30,b08=a20*a33-a23*a30,b09=a21*a32-a22*a31,b10=a21*a33-a23*a31,b11=a22*a33-a23*a32;return this[0]=a11*b11-a12*b10+a13*b09,this[1]=a02*b10-a01*b11-a03*b09,this[2]=a31*b05-a32*b04+a33*b03,this[3]=a22*b04-a21*b05-a23*b03,this[4]=a12*b08-a10*b11-a13*b07,this[5]=a00*b11-a02*b08+a03*b07,this[6]=a32*b02-a30*b05-a33*b01,this[7]=a20*b05-a22*b02+a23*b01,this[8]=a10*b10-a11*b08+a13*b06,this[9]=a01*b08-a00*b10-a03*b06,this[10]=a30*b04-a31*b02+a33*b00,this[11]=a21*b02-a20*b04-a23*b00,this[12]=a11*b07-a10*b09-a12*b06,this[13]=a00*b09-a01*b07+a02*b06,this[14]=a31*b01-a30*b03-a32*b00,this[15]=a20*b03-a21*b01+a22*b00,this}fromFrustum(left,right,bottom,top,near,far){const rl=1/(right-left),tb=1/(top-bottom),nf=1/(near-far);return this[0]=2*near*rl,this[1]=0,this[2]=0,this[3]=0,this[4]=0,this[5]=2*near*tb,this[6]=0,this[7]=0,this[8]=(right+left)*rl,this[9]=(top+bottom)*tb,this[10]=(far+near)*nf,this[11]=-1,this[12]=0,this[13]=0,this[14]=far*near*2*nf,this[15]=0,this}fromQuatTranScale(q,v,s){const x=q[0],y=q[1],z=q[2],w=q[3],x2=x+x,y2=y+y,z2=z+z,xx=x*x2,xy=x*y2,xz=x*z2,yy=y*y2,yz=y*z2,zz=z*z2,wx=w*x2,wy=w*y2,wz=w*z2,sx=s[0],sy=s[1],sz=s[2];return this[0]=(1-(yy+zz))*sx,this[1]=(xy+wz)*sx,this[2]=(xz-wy)*sx,this[3]=0,this[4]=(xy-wz)*sy,this[5]=(1-(xx+zz))*sy,this[6]=(yz+wx)*sy,this[7]=0,this[8]=(xz+wy)*sz,this[9]=(yz-wx)*sz,this[10]=(1-(xx+yy))*sz,this[11]=0,this[12]=v[0],this[13]=v[1],this[14]=v[2],this[15]=1,this}fromQuatTran(q,v){const x=q[0],y=q[1],z=q[2],w=q[3],x2=x+x,y2=y+y,z2=z+z,xx=x*x2,xy=x*y2,xz=x*z2,yy=y*y2,yz=y*z2,zz=z*z2,wx=w*x2,wy=w*y2,wz=w*z2;return this[0]=1-(yy+zz),this[1]=xy+wz,this[2]=xz-wy,this[3]=0,this[4]=xy-wz,this[5]=1-(xx+zz),this[6]=yz+wx,this[7]=0,this[8]=xz+wy,this[9]=yz-wx,this[10]=1-(xx+yy),this[11]=0,this[12]=v[0],this[13]=v[1],this[14]=v[2],this[15]=1,this}fromQuat(q){const x=q[0],y=q[1],z=q[2],w=q[3],x2=x+x,y2=y+y,z2=z+z,xx=x*x2,xy=x*y2,xz=x*z2,yy=y*y2,yz=y*z2,zz=z*z2,wx=w*x2,wy=w*y2,wz=w*z2;return this[0]=1-(yy+zz),this[1]=xy+wz,this[2]=xz-wy,this[3]=0,this[4]=xy-wz,this[5]=1-(xx+zz),this[6]=yz+wx,this[7]=0,this[8]=xz+wy,this[9]=yz-wx,this[10]=1-(xx+yy),this[11]=0,this[12]=0,this[13]=0,this[14]=0,this[15]=1,this}fromQuatTranScaleOrigin(q,v,s,o){const x=q[0],y=q[1],z=q[2],w=q[3],x2=x+x,y2=y+y,z2=z+z,xx=x*x2,xy=x*y2,xz=x*z2,yy=y*y2,yz=y*z2,zz=z*z2,wx=w*x2,wy=w*y2,wz=w*z2,sx=s[0],sy=s[1],sz=s[2],ox=o[0],oy=o[1],oz=o[2],out0=(1-(yy+zz))*sx,out1=(xy+wz)*sx,out2=(xz-wy)*sx,out4=(xy-wz)*sy,out5=(1-(xx+zz))*sy,out6=(yz+wx)*sy,out8=(xz+wy)*sz,out9=(yz-wx)*sz,out10=(1-(xx+yy))*sz;return this[0]=out0,this[1]=out1,this[2]=out2,this[3]=0,this[4]=out4,this[5]=out5,this[6]=out6,this[7]=0,this[8]=out8,this[9]=out9,this[10]=out10,this[11]=0,this[12]=v[0]+ox-(out0*ox+out4*oy+out8*oz),this[13]=v[1]+oy-(out1*ox+out5*oy+out9*oz),this[14]=v[2]+oz-(out2*ox+out6*oy+out10*oz),this[15]=1,this}fromDualQuat(a){const bx=-a[0],by=-a[1],bz=-a[2],bw=a[3],ax=a[4],ay=a[5],az=a[6],aw=a[7],translation=[0,0,0];let magnitude=bx*bx+by*by+bz*bz+bw*bw;return magnitude>0?(magnitude=1/magnitude,translation[0]=2*(ax*bw+aw*bx+ay*bz-az*by)*magnitude,translation[1]=2*(ay*bw+aw*by+az*bx-ax*bz)*magnitude,translation[2]=2*(az*bw+aw*bz+ax*by-ay*bx)*magnitude):(translation[0]=2*(ax*bw+aw*bx+ay*bz-az*by),translation[1]=2*(ay*bw+aw*by+az*bx-ax*bz),translation[2]=2*(az*bw+aw*bz+ax*by-ay*bx)),this.fromQuatTran(a,translation),this}fromLook(eye,center,up){let x0,x1,x2,y0,y1,y2,z0,z1,z2,len;const eyex=eye[0],eyey=eye[1],eyez=eye[2],upx=up[0],upy=up[1],upz=up[2],centerx=center[0],centery=center[1],centerz=center[2];return Math.abs(eyex-centerx)<1e-6&&Math.abs(eyey-centery)<1e-6&&Math.abs(eyez-centerz)<1e-6?(this.identity(),this):(z0=eyex-centerx,z1=eyey-centery,z2=eyez-centerz,len=1/Math.sqrt(z0*z0+z1*z1+z2*z2),z0*=len,z1*=len,z2*=len,x0=upy*z2-upz*z1,x1=upz*z0-upx*z2,x2=upx*z1-upy*z0,len=Math.sqrt(x0*x0+x1*x1+x2*x2),len?(len=1/len,x0*=len,x1*=len,x2*=len):(x0=0,x1=0,x2=0),y0=z1*x2-z2*x1,y1=z2*x0-z0*x2,y2=z0*x1-z1*x0,len=Math.sqrt(y0*y0+y1*y1+y2*y2),len?(len=1/len,y0*=len,y1*=len,y2*=len):(y0=0,y1=0,y2=0),this[0]=x0,this[1]=y0,this[2]=z0,this[3]=0,this[4]=x1,this[5]=y1,this[6]=z1,this[7]=0,this[8]=x2,this[9]=y2,this[10]=z2,this[11]=0,this[12]=-(x0*eyex+x1*eyey+x2*eyez),this[13]=-(y0*eyex+y1*eyey+y2*eyez),this[14]=-(z0*eyex+z1*eyey+z2*eyez),this[15]=1,this)}fromTarget(eye,target,up){const eyex=eye[0],eyey=eye[1],eyez=eye[2],upx=up[0],upy=up[1],upz=up[2];let z0=eyex-target[0],z1=eyey-target[1],z2=eyez-target[2],len=z0*z0+z1*z1+z2*z2;len>0&&(len=1/Math.sqrt(len),z0*=len,z1*=len,z2*=len);let x0=upy*z2-upz*z1,x1=upz*z0-upx*z2,x2=upx*z1-upy*z0;return len=x0*x0+x1*x1+x2*x2,len>0&&(len=1/Math.sqrt(len),x0*=len,x1*=len,x2*=len),this[0]=x0,this[1]=x1,this[2]=x2,this[3]=0,this[4]=z1*x2-z2*x1,this[5]=z2*x0-z0*x2,this[6]=z0*x1-z1*x0,this[7]=0,this[8]=z0,this[9]=z1,this[10]=z2,this[11]=0,this[12]=eyex,this[13]=eyey,this[14]=eyez,this[15]=1,this}fromAxisAngle(axis,rad){let x=axis[0],y=axis[1],z=axis[2],len=Math.hypot(x,y,z);if(len<1e-6)return this;len=1/len,x*=len,y*=len,z*=len;const s=Math.sin(rad),c=Math.cos(rad),t=1-c;return this[0]=x*x*t+c,this[1]=y*x*t+z*s,this[2]=z*x*t-y*s,this[3]=0,this[4]=x*y*t-z*s,this[5]=y*y*t+c,this[6]=z*y*t+x*s,this[7]=0,this[8]=x*z*t+y*s,this[9]=y*z*t-x*s,this[10]=z*z*t+c,this[11]=0,this[12]=0,this[13]=0,this[14]=0,this[15]=1,this}fromRotX(rad){const s=Math.sin(rad),c=Math.cos(rad);return this[0]=1,this[1]=0,this[2]=0,this[3]=0,this[4]=0,this[5]=c,this[6]=s,this[7]=0,this[8]=0,this[9]=-s,this[10]=c,this[11]=0,this[12]=0,this[13]=0,this[14]=0,this[15]=1,this}fromRotY(rad){const s=Math.sin(rad),c=Math.cos(rad);return this[0]=c,this[1]=0,this[2]=-s,this[3]=0,this[4]=0,this[5]=1,this[6]=0,this[7]=0,this[8]=s,this[9]=0,this[10]=c,this[11]=0,this[12]=0,this[13]=0,this[14]=0,this[15]=1,this}fromRotZ(rad){const s=Math.sin(rad),c=Math.cos(rad);return this[0]=c,this[1]=s,this[2]=0,this[3]=0,this[4]=-s,this[5]=c,this[6]=0,this[7]=0,this[8]=0,this[9]=0,this[10]=1,this[11]=0,this[12]=0,this[13]=0,this[14]=0,this[15]=1,this}toNormalMat3(out){const a00=this[0],a01=this[1],a02=this[2],a03=this[3],a10=this[4],a11=this[5],a12=this[6],a13=this[7],a20=this[8],a21=this[9],a22=this[10],a23=this[11],a30=this[12],a31=this[13],a32=this[14],a33=this[15],b00=a00*a11-a01*a10,b01=a00*a12-a02*a10,b02=a00*a13-a03*a10,b03=a01*a12-a02*a11,b04=a01*a13-a03*a11,b05=a02*a13-a03*a12,b06=a20*a31-a21*a30,b07=a20*a32-a22*a30,b08=a20*a33-a23*a30,b09=a21*a32-a22*a31,b10=a21*a33-a23*a31,b11=a22*a33-a23*a32;let det=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;return out=out||[0,0,0,0,0,0,0,0,0],det?(det=1/det,out[0]=(a11*b11-a12*b10+a13*b09)*det,out[1]=(a12*b08-a10*b11-a13*b07)*det,out[2]=(a10*b10-a11*b08+a13*b06)*det,out[3]=(a02*b10-a01*b11-a03*b09)*det,out[4]=(a00*b11-a02*b08+a03*b07)*det,out[5]=(a01*b08-a00*b10-a03*b06)*det,out[6]=(a31*b05-a32*b04+a33*b03)*det,out[7]=(a32*b02-a30*b05-a33*b01)*det,out[8]=(a30*b04-a31*b02+a33*b00)*det,out):out}fromBuf(ary,idx){return this[0]=ary[idx],this[1]=ary[idx+1],this[2]=ary[idx+2],this[3]=ary[idx+3],this[4]=ary[idx+4],this[5]=ary[idx+5],this[6]=ary[idx+6],this[7]=ary[idx+7],this[8]=ary[idx+8],this[9]=ary[idx+9],this[10]=ary[idx+10],this[11]=ary[idx+11],this[12]=ary[idx+12],this[13]=ary[idx+13],this[14]=ary[idx+14],this[15]=ary[idx+15],this}toBuf(ary,idx){return ary[idx]=this[0],ary[idx+1]=this[1],ary[idx+2]=this[2],ary[idx+3]=this[3],ary[idx+4]=this[4],ary[idx+5]=this[5],ary[idx+6]=this[6],ary[idx+7]=this[7],ary[idx+8]=this[8],ary[idx+9]=this[9],ary[idx+10]=this[10],ary[idx+11]=this[11],ary[idx+12]=this[12],ary[idx+13]=this[13],ary[idx+14]=this[14],ary[idx+15]=this[15],this}add(b){return this[0]=this[0]+b[0],this[1]=this[1]+b[1],this[2]=this[2]+b[2],this[3]=this[3]+b[3],this[4]=this[4]+b[4],this[5]=this[5]+b[5],this[6]=this[6]+b[6],this[7]=this[7]+b[7],this[8]=this[8]+b[8],this[9]=this[9]+b[9],this[10]=this[10]+b[10],this[11]=this[11]+b[11],this[12]=this[12]+b[12],this[13]=this[13]+b[13],this[14]=this[14]+b[14],this[15]=this[15]+b[15],this}sub(b){return this[0]=this[0]-b[0],this[1]=this[1]-b[1],this[2]=this[2]-b[2],this[3]=this[3]-b[3],this[4]=this[4]-b[4],this[5]=this[5]-b[5],this[6]=this[6]-b[6],this[7]=this[7]-b[7],this[8]=this[8]-b[8],this[9]=this[9]-b[9],this[10]=this[10]-b[10],this[11]=this[11]-b[11],this[12]=this[12]-b[12],this[13]=this[13]-b[13],this[14]=this[14]-b[14],this[15]=this[15]-b[15],this}mul(b){const a00=this[0],a01=this[1],a02=this[2],a03=this[3],a10=this[4],a11=this[5],a12=this[6],a13=this[7],a20=this[8],a21=this[9],a22=this[10],a23=this[11],a30=this[12],a31=this[13],a32=this[14],a33=this[15];let b0=b[0],b1=b[1],b2=b[2],b3=b[3];return this[0]=b0*a00+b1*a10+b2*a20+b3*a30,this[1]=b0*a01+b1*a11+b2*a21+b3*a31,this[2]=b0*a02+b1*a12+b2*a22+b3*a32,this[3]=b0*a03+b1*a13+b2*a23+b3*a33,b0=b[4],b1=b[5],b2=b[6],b3=b[7],this[4]=b0*a00+b1*a10+b2*a20+b3*a30,this[5]=b0*a01+b1*a11+b2*a21+b3*a31,this[6]=b0*a02+b1*a12+b2*a22+b3*a32,this[7]=b0*a03+b1*a13+b2*a23+b3*a33,b0=b[8],b1=b[9],b2=b[10],b3=b[11],this[8]=b0*a00+b1*a10+b2*a20+b3*a30,this[9]=b0*a01+b1*a11+b2*a21+b3*a31,this[10]=b0*a02+b1*a12+b2*a22+b3*a32,this[11]=b0*a03+b1*a13+b2*a23+b3*a33,b0=b[12],b1=b[13],b2=b[14],b3=b[15],this[12]=b0*a00+b1*a10+b2*a20+b3*a30,this[13]=b0*a01+b1*a11+b2*a21+b3*a31,this[14]=b0*a02+b1*a12+b2*a22+b3*a32,this[15]=b0*a03+b1*a13+b2*a23+b3*a33,this}pmul(b){const a00=b[0],a01=b[1],a02=b[2],a03=b[3],a10=b[4],a11=b[5],a12=b[6],a13=b[7],a20=b[8],a21=b[9],a22=b[10],a23=b[11],a30=b[12],a31=b[13],a32=b[14],a33=b[15];let b0=this[0],b1=this[1],b2=this[2],b3=this[3];return this[0]=b0*a00+b1*a10+b2*a20+b3*a30,this[1]=b0*a01+b1*a11+b2*a21+b3*a31,this[2]=b0*a02+b1*a12+b2*a22+b3*a32,this[3]=b0*a03+b1*a13+b2*a23+b3*a33,b0=this[4],b1=this[5],b2=this[6],b3=this[7],this[4]=b0*a00+b1*a10+b2*a20+b3*a30,this[5]=b0*a01+b1*a11+b2*a21+b3*a31,this[6]=b0*a02+b1*a12+b2*a22+b3*a32,this[7]=b0*a03+b1*a13+b2*a23+b3*a33,b0=this[8],b1=this[9],b2=this[10],b3=this[11],this[8]=b0*a00+b1*a10+b2*a20+b3*a30,this[9]=b0*a01+b1*a11+b2*a21+b3*a31,this[10]=b0*a02+b1*a12+b2*a22+b3*a32,this[11]=b0*a03+b1*a13+b2*a23+b3*a33,b0=this[12],b1=this[13],b2=this[14],b3=this[15],this[12]=b0*a00+b1*a10+b2*a20+b3*a30,this[13]=b0*a01+b1*a11+b2*a21+b3*a31,this[14]=b0*a02+b1*a12+b2*a22+b3*a32,this[15]=b0*a03+b1*a13+b2*a23+b3*a33,this}invert(){const a00=this[0],a01=this[1],a02=this[2],a03=this[3],a10=this[4],a11=this[5],a12=this[6],a13=this[7],a20=this[8],a21=this[9],a22=this[10],a23=this[11],a30=this[12],a31=this[13],a32=this[14],a33=this[15],b00=a00*a11-a01*a10,b01=a00*a12-a02*a10,b02=a00*a13-a03*a10,b03=a01*a12-a02*a11,b04=a01*a13-a03*a11,b05=a02*a13-a03*a12,b06=a20*a31-a21*a30,b07=a20*a32-a22*a30,b08=a20*a33-a23*a30,b09=a21*a32-a22*a31,b10=a21*a33-a23*a31,b11=a22*a33-a23*a32;let det=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;return det?(det=1/det,this[0]=(a11*b11-a12*b10+a13*b09)*det,this[1]=(a02*b10-a01*b11-a03*b09)*det,this[2]=(a31*b05-a32*b04+a33*b03)*det,this[3]=(a22*b04-a21*b05-a23*b03)*det,this[4]=(a12*b08-a10*b11-a13*b07)*det,this[5]=(a00*b11-a02*b08+a03*b07)*det,this[6]=(a32*b02-a30*b05-a33*b01)*det,this[7]=(a20*b05-a22*b02+a23*b01)*det,this[8]=(a10*b10-a11*b08+a13*b06)*det,this[9]=(a01*b08-a00*b10-a03*b06)*det,this[10]=(a30*b04-a31*b02+a33*b00)*det,this[11]=(a21*b02-a20*b04-a23*b00)*det,this[12]=(a11*b07-a10*b09-a12*b06)*det,this[13]=(a00*b09-a01*b07+a02*b06)*det,this[14]=(a31*b01-a30*b03-a32*b00)*det,this[15]=(a20*b03-a21*b01+a22*b00)*det,this):this}translate(v,y,z){let xx,yy,zz;if(v instanceof Float32Array||v instanceof Array&&3==v.length)xx=v[0],yy=v[1],zz=v[2];else{if("number"!=typeof v||"number"!=typeof y||"number"!=typeof z)return this;xx=v,yy=y,zz=z}return this[12]=this[0]*xx+this[4]*yy+this[8]*zz+this[12],this[13]=this[1]*xx+this[5]*yy+this[9]*zz+this[13],this[14]=this[2]*xx+this[6]*yy+this[10]*zz+this[14],this[15]=this[3]*xx+this[7]*yy+this[11]*zz+this[15],this}scale(x,y,z){return null==y&&(y=x),null==z&&(z=x),this[0]*=x,this[1]*=x,this[2]*=x,this[3]*=x,this[4]*=y,this[5]*=y,this[6]*=y,this[7]*=y,this[8]*=z,this[9]*=z,this[10]*=z,this[11]*=z,this}transpose(){const a01=this[1],a02=this[2],a03=this[3],a12=this[6],a13=this[7],a23=this[11];return this[1]=this[4],this[2]=this[8],this[3]=this[12],this[4]=a01,this[6]=this[9],this[7]=this[13],this[8]=a02,this[9]=a12,this[11]=this[14],this[12]=a03,this[13]=a13,this[14]=a23,this}decompose(out_r,out_t,out_s){out_t[0]=this[12],out_t[1]=this[13],out_t[2]=this[14];const m11=this[0],m12=this[1],m13=this[2],m21=this[4],m22=this[5],m23=this[6],m31=this[8],m32=this[9],m33=this[10];out_s[0]=Math.hypot(m11,m12,m13),out_s[1]=Math.hypot(m21,m22,m23),out_s[2]=Math.hypot(m31,m32,m33);const is1=1/out_s[0],is2=1/out_s[1],is3=1/out_s[2],sm11=m11*is1,sm12=m12*is2,sm13=m13*is3,sm21=m21*is1,sm22=m22*is2,sm23=m23*is3,sm31=m31*is1,sm32=m32*is2,sm33=m33*is3,trace=sm11+sm22+sm33;let S=0;return trace>0?(S=2*Math.sqrt(trace+1),out_r[3]=.25*S,out_r[0]=(sm23-sm32)/S,out_r[1]=(sm31-sm13)/S,out_r[2]=(sm12-sm21)/S):sm11>sm22&&sm11>sm33?(S=2*Math.sqrt(1+sm11-sm22-sm33),out_r[3]=(sm23-sm32)/S,out_r[0]=.25*S,out_r[1]=(sm12+sm21)/S,out_r[2]=(sm31+sm13)/S):sm22>sm33?(S=2*Math.sqrt(1+sm22-sm11-sm33),out_r[3]=(sm31-sm13)/S,out_r[0]=(sm12+sm21)/S,out_r[1]=.25*S,out_r[2]=(sm23+sm32)/S):(S=2*Math.sqrt(1+sm33-sm11-sm22),out_r[3]=(sm12-sm21)/S,out_r[0]=(sm31+sm13)/S,out_r[1]=(sm23+sm32)/S,out_r[2]=.25*S),this}rotX(rad){const s=Math.sin(rad),c=Math.cos(rad),a10=this[4],a11=this[5],a12=this[6],a13=this[7],a20=this[8],a21=this[9],a22=this[10],a23=this[11];return this[4]=a10*c+a20*s,this[5]=a11*c+a21*s,this[6]=a12*c+a22*s,this[7]=a13*c+a23*s,this[8]=a20*c-a10*s,this[9]=a21*c-a11*s,this[10]=a22*c-a12*s,this[11]=a23*c-a13*s,this}rotY(rad){const s=Math.sin(rad),c=Math.cos(rad),a00=this[0],a01=this[1],a02=this[2],a03=this[3],a20=this[8],a21=this[9],a22=this[10],a23=this[11];return this[0]=a00*c-a20*s,this[1]=a01*c-a21*s,this[2]=a02*c-a22*s,this[3]=a03*c-a23*s,this[8]=a00*s+a20*c,this[9]=a01*s+a21*c,this[10]=a02*s+a22*c,this[11]=a03*s+a23*c,this}rotZ(rad){const s=Math.sin(rad),c=Math.cos(rad),a00=this[0],a01=this[1],a02=this[2],a03=this[3],a10=this[4],a11=this[5],a12=this[6],a13=this[7];return this[0]=a00*c+a10*s,this[1]=a01*c+a11*s,this[2]=a02*c+a12*s,this[3]=a03*c+a13*s,this[4]=a10*c-a00*s,this[5]=a11*c-a01*s,this[6]=a12*c-a02*s,this[7]=a13*c-a03*s,this}rotAxisAngle(axis,rad){let x=axis[0],y=axis[1],z=axis[2],len=Math.sqrt(x*x+y*y+z*z);if(Math.abs(len)<1e-6)return this;len=1/len,x*=len,y*=len,z*=len;const s=Math.sin(rad),c=Math.cos(rad),t=1-c,a00=this[0],a01=this[1],a02=this[2],a03=this[3],a10=this[4],a11=this[5],a12=this[6],a13=this[7],a20=this[8],a21=this[9],a22=this[10],a23=this[11],b00=x*x*t+c,b01=y*x*t+z*s,b02=z*x*t-y*s,b10=x*y*t-z*s,b11=y*y*t+c,b12=z*y*t+x*s,b20=x*z*t+y*s,b21=y*z*t-x*s,b22=z*z*t+c;return this[0]=a00*b00+a10*b01+a20*b02,this[1]=a01*b00+a11*b01+a21*b02,this[2]=a02*b00+a12*b01+a22*b02,this[3]=a03*b00+a13*b01+a23*b02,this[4]=a00*b10+a10*b11+a20*b12,this[5]=a01*b10+a11*b11+a21*b12,this[6]=a02*b10+a12*b11+a22*b12,this[7]=a03*b10+a13*b11+a23*b12,this[8]=a00*b20+a10*b21+a20*b22,this[9]=a01*b20+a11*b21+a21*b22,this[10]=a02*b20+a12*b21+a22*b22,this[11]=a03*b20+a13*b21+a23*b22,this}transformVec3(v,out=[0,0,0]){const x=v[0],y=v[1],z=v[2];return out[0]=this[0]*x+this[4]*y+this[8]*z+this[12],out[1]=this[1]*x+this[5]*y+this[9]*z+this[13],out[2]=this[2]*x+this[6]*y+this[10]*z+this[14],out}transformVec4(v,out=[0,0,0,0]){const x=v[0],y=v[1],z=v[2],w=v[3];return out[0]=this[0]*x+this[4]*y+this[8]*z+this[12]*w,out[1]=this[1]*x+this[5]*y+this[9]*z+this[13]*w,out[2]=this[2]*x+this[6]*y+this[10]*z+this[14]*w,out[3]=this[3]*x+this[7]*y+this[11]*z+this[15]*w,out}static mul(a,b){return(new Mat4).fromMul(a,b)}static invert(a){return(new Mat4).fromInvert(a)}}export{Armature,Bone,BoneAxes,BoneBindings,BoneMap,BoneSockets,IKChain,IKLink,IKRig,IKTarget,IK_SOLVERS,Mat4,Maths,Pose,Quat,Transform,Vec3,asincArcCompose,deltaMoveSolver,limbCompose,lookCompose,lookSolver,rootCompose,swingTwistChainSolver,trapezoidCompose,trapezoidSolver,twoBoneSolver,zCompose,ZSolver as zSolver};